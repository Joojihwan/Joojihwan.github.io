{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"JavaBeans","text":"** 엔터프라이즈 자바빈즈(EJB) 와 혼동하지 말아야 한다. ** EJB는 자바 플랫폼, 엔터프라이즈 에디션 (Java EE)의 일부로서 서버 계열의 컴포넌트이다. JavaBeans의 관례 JavaBeans Class로서 작동하기 위해, 객체클래스는 명명법, 생성법 그리고 일련의 관례를 따라야한다. 클래스는 직렬화 되어야 한다. ( 지속적으로 저장, 복원하기 위해) 기본 생성자를 가져야 한다. get, set 혹은 표준 명명법을 따르는 메서들을 통해 속성에 접근 할 수 있어야한다. 필요한 이벤트 처리 메서드들을 포함하고 있어야 한다. 예시 코드 12345678910111213141516171819202122public class PersonBean implements java.io.Serializable{ private String name; private boolean coding; public PersonBean(){} // 기본 생성자 public String getName(){ return this.name; } public void setName(){ this.name = name; } public boolean isCoding(){ // boolean field has different semantic (is) return this.coding; } public void setCoding(boolean coding){ this.coding = coding; }}","link":"/2021/04/05/JavaBeans/"},{"title":"RMI","text":"아래 내용은 간단히 요약된 것으로 자세한 내용은 아래 링크를 참고하시기 바랍니다. 허니문(Honeymon)의 자바guru 공유민 블로그 RMI ( Remote Method Invocation ) 분산되어 있는 객체간의 메시지 전송 혹은 메소드 호출을 가능하게 하는 프로토콜 분산객체 간의 통신을 구현하는 모든 프로토콜 (CORBA, DCOM … ) RPC ( Remote Procedure Call ) UNIX에서 가장 많이 사용되는 통신 프로토콜 네크워크에 연결되어 있는 다른 컴퓨터의 함수를 실행, 분산 시스템 구현 객체지향이 아닌 순차적인 언어로 개발된 함수만을 호출 RMI 개발 목적 안정된 원격 호출 Server -&gt; Applet Callback 분산 모델을 자바환경으로 통합 RMI 의 장점 구현이 쉽다. 소켓 통신을 하부에 숨기고 상위 레벨에서 수행 신뢰성 보장 상위 레벨의 통신계층에서 수앻 자바 자체 제공 라이브러리 Java 플랫폼 사용 JVM에서 활용 가능 Remote Machine &lt;-&gt; Local Machine Remote Machine은 Server 이름을 가지고 Registry에 bind Local machine은 Registry에서 Server 이름 조회 Stub 과 Skeletion 간 Serialize 된 data를 주고 받는다.","link":"/2021/04/06/RMI/"},{"title":"SSAFY","text":"블로그를 만들고 쓰게 되면서 SSAFY를 되돌아 보고 정리하는 내용을 써야겠다고 생각했다. 보안에 위배되지 않는 선에서 정리하기 위해 개인적으로 느낀 것, 얻은 것들을 중심으로 정리하려한다. SSAFY 3기 지원 이유 전자공학에서 SW공부를 나름 하고 있었지만 전공자들보다 모자람을 느껴 기본기를 다지기 위해서 지원했다. 삼성 상시 역량테스트 준비를 반 년정도 독학으로 하면서 A등급을 미리 취득한 상태로 지원했기 때문에 유리한 점도 있었다고 생각한다. 특히 면접에서는 내가 왜 지원했고, 얼마나 열심히 할 자신이 있는지를 어필했다. 내가 얻은 것 삼성전자 이사상 최우수상! 을 받은 것은 누구에게나 인정받을만한 성과다. 1년 과정 전체를 평가 받아 수상한 것이기 때문에 그 의미는 더 깊다고 볼 수 있다. 사실 1등을 하겠다는 목표를 가지고 입소한 것은 아니었다. 그런데 처음 교육을 들었을 때 전공자 사이에서 내가 많이 부족함을 체감하는 순간 학습 의지가 불타올랐다. 그리고 2월… 코시국의 시작으로 정말 아무것도 하지 않고 공부만 할 여건이 제대로 갖춰졌다. 정말 1년 동안은 코딩말고 한게 없다. 하나도 몰랐던 기술 스택을 많이 사용할 수 있게 됐고, 이제 자신할 수 있다. 지금의 나는 왠만한 전공자보다 많이 공부했고, 잘할 수 있다. 그리고 가장 중요한 것, 짧은 시간동안 그 많은 걸 공부해 결과물을 만들어냈는데 앞으로 뭔들 해낼 수 있다는 자신감이 생겼다. 21년 4월 지금 4기 실습코치로 근무한지도 4달 째, 삼성전자만 바라봤던 작년과 다르게 여러 기업에 지원하고 면접을 보면서 아직 부족함을 절실히 느꼈다. 분명 결과물을 위한 얕은 학습만 해왔기 때문에 이제는 깊이 있는 학습이 필요하다는 생각이 강하게 들었고, 이 블로그에 공부한 내용을 정리하기 시작한 이유이기도 하다.","link":"/2021/04/07/SSAFY/"},{"title":"Java Inner Class","text":"Java Inner Class (Nested Class) Inner Class Private Inner Class Static Inner Class Inner Class에서 Outer Class 접근 Inner Class JDK 1.1 부터 클래스를 중첩하여 선언하고 사용할 수 있습니다. 함께 속한 클래스를 그룹화해 가독성과 유지 관리를 향상시킵니다. Inner Class에 접근하려면 Outer Class의 Object를 통해 Inner Class Object를 만듭니다. 예시 코드 12345678910111213141516class OuterClass{ int a = 1; class InnerClass{ int b = 2; }}public class Main{ public static void main(String[] args){ OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); int c = outerClass.a + innerClass.b; // c = 1 + 2 }} Private Inner Class 일반 클래스와 달리 Inner Class는 private 또는 protected 일 수 있습니다. 외부에서 private Inner Class에 접근할 시 오류가 발생합니다. 예시 코드 123456789101112131415161718class OuterClass{ int a = 1; private class InnerClass{ int b = 2; }}public class Main{ public static void main(String[] args){ OuterClass outerClass = new OuterClass(); // 에러 발생 지점 OuterClass.InnerClass innerClass = outerClass.new InnerClass(); int c = outerClass.a + innerClass.b; // c = 1 + 2 }} Static Inner Class Static으로 Inner Class를 선언할 수 있으며 Outer Class Object 없이 접근 가능합니다. 예시 코드 1234567891011121314class OuterClass{ int a = 1; static class InnerClass{ int b = 2; }}public class Main { public static void main(String[] args) { OuterClass.InnerClass innerClass = new OuterClass.InnerClass(); int c = innerClass.y; // c = 2 }} Inner Class 에서 Outer Class 접근 Inner Class에서 Outer Class의 attribute와 method에 접근 가능합니다. 예시 코드 12345678class OuterClass{ int a = 1; class InnerClass{ public int innerMethod(){ return a; } }}","link":"/2021/04/05/inner-class/"},{"title":"자바 버전별 특징","text":"Version 발표일 특징 비고 JDK 1.0a 1994 JDK 1.0a2 1995.05.23 - 자바 언어가 정식으로 발표된 날 JDK 1.0 1996.01.23 - Oak로 불렸으나, 안정화 작업을 거친 1.0.2부터 JAVA로 변경 JDK 1.1 1997.02.19 - inner class- JavaBeans- RMI- reflection- unicode- 국제화 (internationallization) J2SE 1.2 1998.12.08 - strictfp- SWING GUI- JIT CORBA- Collections - JDK -&gt; J2SE로 변경 (J2SE 5까지 사용)- 1999년 업데이트를 통한 HotSpot JVM J2SE 1.3 2000.03.08 - HotSpot JVM- JNDI- JPDA- JavaSound - RMI가 CORBA 지원 J2SE 1.4 2002.02.06 - assert- regular expression- NIO-IPv6- XMl API- JCE- JSSE- JAAS-Java Web Start J2SE 5 2004.09.30 - generics- annotation- auto boxing/unboxing- enumeration- 가변길이 파라미터- static import- concurrency API - 버전 중 1을 빼고 표기 (내부적으로는 1.5, 1.6, 1.7 등을 사용) Java SE 6 2006.12.11 - interface에 @Override 추가됨- JDBC 4.0- Scripting Language Support- Java Compiler API- pluggable annotation - J2SE -&gt; Java SE로 변경 Java SE 7 2011.07.07 - diamond operator&lt;&gt;- try-resource- multi-catch- switch문에 String 사용- concurrency API(new)- Java2D 지원- dynamic language 지원 Java SE 8 2014.03.18 - lambda expression- type annotation- stream api 추가- repeating annotation- static link library- interface default method- unsigned integer 계산- 날짜와 시간 API(new) -&gt; JodaTime- rhino 대신 nashorn javascript 엔진 탐재 - 32bit 지원 마지막 공식 버전 Java SE 9 2017.09.21 - Jingsau 기반 런타임 모듈화(module)- JShell 추가(인터프리터 셀처럼 사용)- private interface method- immutable collection- 통합 로깅 - HTTP/2- HTML 5 JavaDoc- 프로퍼티 파일에 UTF-8 지원 - 버전을 1.x로 하지 않고 9.0으로 변경- Ahead-of-time compiler 시범 적용- Java Applet 기능 종료- 64bit 버전만 출시 Java SE 10 2018.03.20 - var 키워드 이용한 지역변수 타입 추론- 병렬처리 가비지 컬렉터- 개별 Thread로 분리된 Stop-The World- 루트 CA- JVM heap영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당 - JDK 레포지토리가 하나로 통합- Java기반 JIT 컴파일러- 이전 버전 deprecated 처리된 API 삭제 JAVA SE 11 2018.09.25 - lambda 파라미터에 대한 지역변수 문법- 엡실론 가비지 컬렉터- HTTP 클라이언트 표준화 - OracleJDK의 독접기능이 OpenJDK에 이식 (OracleJDK와 OpenJDK가 동일해짐)- 2019년 1월부터 OracleJDK가 유료 모델로 전환- eclipse 재단으로 넘어간 Java EE 삭제- JavaFX도 JDK에서 분리하여 모듈 제공 Java SE 12 2019.03.19 - switch문 확장 (-&gt;)- 가비지 컬렉터 개선- 마이크로 벤치마크 툴 추가- 성능 개선 JAVA SE 13 2019.09.17 - switch 문에 yield 예약어 추가","link":"/2021/04/05/java-feature/"},{"title":"Reflection","text":": 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법 Object.getClass()를 통해 클래스 정보를 로드 예시 코드 123456789101112Class c = &quot;foo&quot;.getClass();System.out.println(c); // 출력 : class java.lang.Stringbyte[] b = new byte[1024];System.out.println(b.getClass()); // 출력 : class [Bint a = 1;System.out.println(a.getClass()); // 에러 발생Integer d = 1;System.out.println(d.getClass()); // 에러 발생System.out.println(Integer.TYPE); // 출력 : int Method를 활용한 클래스 반환 Class.getSuperClass() Class.getClass() Class.getDeclaredClass() Class.getDeclaringClass() … 예시 코드 12Class c = Double.TYPE;System.out.println(c.getDeclaredClasses()); // 출력 : [Ljava.lang.Class;@2a139a55 특징 확장성 클래스 브라우저 및 시각적 개발 환경 제공 디버거 및 테스트 도구 사용 시 유의할 점 Peformance 오버헤드 Reflection 작업 시 성능이 떨어질 수 있음 보안 제한 사항 java 보안 제약 조건 위반을 허용 캡슐화 저해 가독성 저하 참고 링크 : https://docs.oracle.com/javase/tutorial/reflect/","link":"/2021/04/07/Reflection/"},{"title":"호텔방배정","text":"12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;class Solution { public long[] solution(long k, long[] room_number) { long[] answer = new long[room_number.length]; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; room_number.length; i++) { answer[i] = getRoomNumber(map, room_number[i]); } return answer; } static long getRoomNumber(Map&lt;Long, Long&gt; map, long n) { if(map.get(n) == null) { map.put(n , n + 1); return n; } else { long res = getRoomNumber(map, map.get(n)); map.replace(n , res + 1); return res; } }}","link":"/2021/04/12/%ED%98%B8%ED%85%94%EB%B0%A9%EB%B0%B0%EC%A0%95/"},{"title":"JPA","text":"JPA에 대한 학습하며 꾸준히 업데이트하는 게시물입니다. JPA ( Java Persistence API ) JPA는 표준 ORM (Object-Relational Mapping) 으로 Spring이 아닌 Java에서 제공하는 APIEJB에서 제공되던 Entity Bean을 대체하는 기술 SQL Mapper 과 ORM의 차이 SQL Mapper : SQL과 Object Field를 매핑 SQL 문장으로 직접 DB를 다룬다. 즉 SQL을 명시해야한다. 대표적으로 Mybatis, JdbcTempletes 등이 있다. ORM : DB와 Object Field를 매핑 직관적인 코드(Method)로 데이터를 조작 객체간의 관계를 바탕으로 SQL을 자동 생성 JPA, Hibernate Spring Data JPA JPA는 Interface, Hibernate는 JPA의 구현체, Spring Data JPA는 모듈. Spring Data JPA는 Spring에서 제공하는 모듈 중 하나로, JPA의 사용이 쉽도록 도와준다. 이는 JPA를 한 단계 추상화시킨 Repository라는 Interface를 제공하여 이루어진다. Repository Interface에 정해진 규칙대로 Method를 입력하면 적합한 Query를 날리는 구현체를 만들어 Bean으로 등록한다. Hibernate의 특징 JDBC의 단점인 유사 작업 반복, 객체 지향적이지 못함을 해결할 수 있다. 장점 생산성 유지보수 종속적이지 않음 단점 성능 세밀함 러닝커브 JPA를 사용하려면 @Entity -&gt; Table Repository -&gt; Query application.properties / application.yml 에 추가할 내용 JPA Repository CRUD Method Name READ find____ 로 시작 Delete delete____ 로 시작 Create save Update READ 한 값 변경 -&gt; save JPA에서 기본으로 제공하지않는 Method를 Repository interface에 추가하여 사용할 수 있다. 참고 링크 : Spring Docs @BuilderLombok 의 Builder를 사용하면 객체 생성에서 편리함을 가질 수 있다.","link":"/2021/04/14/JPA/"},{"title":"풍선 터트리기","text":"12345678910111213141516171819202122232425262728293031323334353637class Solution { public int solution(int[] a) { int answer = 2; int[] l = new int[a.length]; int[] r = new int[a.length]; setMin(a,l,r); for(int i = 1; i &lt; a.length - 1; i++){ if(l[i - 1] &lt; a[i] &amp;&amp; r[i + 1] &lt; a[i]) continue; answer++; } return answer; } public void setMin(int[] a, int[] l, int[] r){ int size = a.length; int leftMin = a[0]; int rightMin = a[size - 1]; l[0] = leftMin; r[size - 1] = rightMin; for(int i = 1; i &lt; size; i++){ if(leftMin &gt; a[i]){ leftMin = a[i]; } if(rightMin &gt; a[size - i]){ rightMin = a[size - i]; } l[i] = leftMin; r[size - i] = rightMin; } }}","link":"/2021/04/14/%ED%92%8D%EC%84%A0%20%ED%84%B0%ED%8A%B8%EB%A6%AC%EA%B8%B0/"}],"tags":[{"name":"JDK_1.1","slug":"JDK-1-1","link":"/tags/JDK-1-1/"},{"name":"JavaBeans","slug":"JavaBeans","link":"/tags/JavaBeans/"},{"name":"RMI","slug":"RMI","link":"/tags/RMI/"},{"name":"SSAFY","slug":"SSAFY","link":"/tags/SSAFY/"},{"name":"Inner Class","slug":"Inner-Class","link":"/tags/Inner-Class/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Programmers","slug":"Programmers","link":"/tags/Programmers/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"SSAFY","slug":"SSAFY","link":"/categories/SSAFY/"},{"name":"JDK_1.1","slug":"Java/JDK-1-1","link":"/categories/Java/JDK-1-1/"},{"name":"되돌아보기","slug":"SSAFY/되돌아보기","link":"/categories/SSAFY/%EB%90%98%EB%8F%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"},{"name":"알고리즘 풀이","slug":"알고리즘-풀이","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4/"},{"name":"프로그래머스","slug":"알고리즘-풀이/프로그래머스","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"Level 4","slug":"알고리즘-풀이/프로그래머스/Level-4","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/Level-4/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"JPA","slug":"Spring/JPA","link":"/categories/Spring/JPA/"},{"name":"Level 3","slug":"알고리즘-풀이/프로그래머스/Level-3","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/Level-3/"},{"name":"정리","slug":"Java/정리","link":"/categories/Java/%EC%A0%95%EB%A6%AC/"}]}