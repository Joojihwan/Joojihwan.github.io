{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Java Inner Class","text":"Java Inner Class (Nested Class) Inner Class Private Inner Class Static Inner Class Inner Class에서 Outer Class 접근 Inner Class JDK 1.1 부터 클래스를 중첩하여 선언하고 사용할 수 있습니다. 함께 속한 클래스를 그룹화해 가독성과 유지 관리를 향상시킵니다. Inner Class에 접근하려면 Outer Class의 Object를 통해 Inner Class Object를 만듭니다. 예시 코드 12345678910111213141516class OuterClass{ int a = 1; class InnerClass{ int b = 2; }}public class Main{ public static void main(String[] args){ OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); int c = outerClass.a + innerClass.b; // c = 1 + 2 }} Private Inner Class 일반 클래스와 달리 Inner Class는 private 또는 protected 일 수 있습니다. 외부에서 private Inner Class에 접근할 시 오류가 발생합니다. 예시 코드 123456789101112131415161718class OuterClass{ int a = 1; private class InnerClass{ int b = 2; }}public class Main{ public static void main(String[] args){ OuterClass outerClass = new OuterClass(); // 에러 발생 지점 OuterClass.InnerClass innerClass = outerClass.new InnerClass(); int c = outerClass.a + innerClass.b; // c = 1 + 2 }} Static Inner Class Static으로 Inner Class를 선언할 수 있으며 Outer Class Object 없이 접근 가능합니다. 예시 코드 1234567891011121314class OuterClass{ int a = 1; static class InnerClass{ int b = 2; }}public class Main { public static void main(String[] args) { OuterClass.InnerClass innerClass = new OuterClass.InnerClass(); int c = innerClass.y; // c = 2 }} Inner Class 에서 Outer Class 접근 Inner Class에서 Outer Class의 attribute와 method에 접근 가능합니다. 예시 코드 12345678class OuterClass{ int a = 1; class InnerClass{ public int innerMethod(){ return a; } }}","link":"/2021/04/05/inner-class/"},{"title":"자바 버전별 특징","text":"Version 발표일 특징 비고 JDK 1.0a 1994 JDK 1.0a2 1995.05.23 - 자바 언어가 정식으로 발표된 날 JDK 1.0 1996.01.23 - Oak로 불렸으나, 안정화 작업을 거친 1.0.2부터 JAVA로 변경 JDK 1.1 1997.02.19 - inner class- JavaBeans- RMI- reflection- unicode- 국제화 (internationallization) J2SE 1.2 1998.12.08 - strictfp- SWING GUI- JIT CORBA- Collections - JDK -&gt; J2SE로 변경 (J2SE 5까지 사용)- 1999년 업데이트를 통한 HotSpot JVM J2SE 1.3 2000.03.08 - HotSpot JVM- JNDI- JPDA- JavaSound - RMI가 CORBA 지원 J2SE 1.4 2002.02.06 - assert- regular expression- NIO-IPv6- XMl API- JCE- JSSE- JAAS-Java Web Start J2SE 5 2004.09.30 - generics- annotation- auto boxing/unboxing- enumeration- 가변길이 파라미터- static import- concurrency API - 버전 중 1을 빼고 표기 (내부적으로는 1.5, 1.6, 1.7 등을 사용) Java SE 6 2006.12.11 - interface에 @Override 추가됨- JDBC 4.0- Scripting Language Support- Java Compiler API- pluggable annotation - J2SE -&gt; Java SE로 변경 Java SE 7 2011.07.07 - diamond operator&lt;&gt;- try-resource- multi-catch- switch문에 String 사용- concurrency API(new)- Java2D 지원- dynamic language 지원 Java SE 8 2014.03.18 - lambda expression- type annotation- stream api 추가- repeating annotation- static link library- interface default method- unsigned integer 계산- 날짜와 시간 API(new) -&gt; JodaTime- rhino 대신 nashorn javascript 엔진 탐재 - 32bit 지원 마지막 공식 버전 Java SE 9 2017.09.21 - Jingsau 기반 런타임 모듈화(module)- JShell 추가(인터프리터 셀처럼 사용)- private interface method- immutable collection- 통합 로깅 - HTTP/2- HTML 5 JavaDoc- 프로퍼티 파일에 UTF-8 지원 - 버전을 1.x로 하지 않고 9.0으로 변경- Ahead-of-time compiler 시범 적용- Java Applet 기능 종료- 64bit 버전만 출시 Java SE 10 2018.03.20 - var 키워드 이용한 지역변수 타입 추론- 병렬처리 가비지 컬렉터- 개별 Thread로 분리된 Stop-The World- 루트 CA- JVM heap영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당 - JDK 레포지토리가 하나로 통합- Java기반 JIT 컴파일러- 이전 버전 deprecated 처리된 API 삭제 JAVA SE 11 2018.09.25 - lambda 파라미터에 대한 지역변수 문법- 엡실론 가비지 컬렉터- HTTP 클라이언트 표준화 - OracleJDK의 독접기능이 OpenJDK에 이식 (OracleJDK와 OpenJDK가 동일해짐)- 2019년 1월부터 OracleJDK가 유료 모델로 전환- eclipse 재단으로 넘어간 Java EE 삭제- JavaFX도 JDK에서 분리하여 모듈 제공 Java SE 12 2019.03.19 - switch문 확장 (-&gt;)- 가비지 컬렉터 개선- 마이크로 벤치마크 툴 추가- 성능 개선 JAVA SE 13 2019.09.17 - switch 문에 yield 예약어 추가","link":"/2021/04/05/java-feature/"}],"tags":[],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"}]}